/*malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。
调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。
然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。
接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。
调用free函数时，它将用户释放的内存块连接到空闲链上。
到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。
于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。
如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。
*/
extern void *malloc(unsigned int num_bytes);//原型

//头文件
#include <stdlib.h>
//或者
#include <malloc.h>

void *malloc(size_t size);
/*备注：void* 表示未确定类型的指针，void *可以指向任何类型的数据，
更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者其他数据类型）。
如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。
当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。*/
type *p;
if(NULL == (p = (type*)malloc(sizeof(type))))
/*请使用if来判断,这是有必要的*/
{
    perror("error...");
    exit(1);
}
//...其它代码
free(p);
p = NULL;/*请加上这句*/
